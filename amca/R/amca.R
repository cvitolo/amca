#' Run the AMCA algorithm.
#'
#' @param DATA This is a data.frame containing the observed time series (zoo objects). It is structured into three columns: P containing precipitation, E containing potential evapotranspiration and Q containing streamflow discharge.
#' @param ResultsFolder Path to the folder containing results from MC simulations.
#' @param parameters is a data.frame containing all the parameter sets. This can be generated by \code{fuse::generateParameters()}.
#' @param ObsIndicesNames Names of model performance indices.
#' @param selectedModels (OPTIONAL) This is a table that contains at list 1 column named \code{mid} (list of model structures). Other informations can be added as additional columns but will be ignored (default = NULL).
#' @param warmup Percentage of initial time steps to ignore (default is 0.5 that corresponds to 50 percent of the full length).
#' @param verbose if set to TRUE it prints running information (default is FALSE).
#' @param PreSel if set to FALSE the preliminary selection step is skipped (default is TRUE).
#'
#' @return A list of suggested model configurations.
#'
#' @examples
#' # results <- amca(DATA, ResultsFolder)
#'

amca <- function(DATA, ResultsFolder, parameters,
                 ObsIndicesNames = c("LAGTIME","MAE","NSHF","NSLF"),
                 selectedModels = NULL, warmup=NULL, verbose=TRUE, PreSel=TRUE){

  # For testing:
  # DATA <- readRDS("~/amca/syntheticDATA.rds")
  # ResultsFolder <- "~/amca/synthetic/"
  # selectedModels <- seq(1,1248,2)
  # warmup=NULL; verbose=TRUE; PreSel=TRUE

  ##############################################################################
  # Preparing forcing inputs ###################################################
  ##############################################################################

  options(warn=-1) # do not print warnings

  if ( is.null(ResultsFolder) ) {
    message("Please specify ResultsFolder.")
    stop
  }

  if ( is.null(warmup) ) {
    # period to warmup the model
    fractionWarmUp <- 0.50 # 50%
    warmup <- ifelse(fractionWarmUp==0,0,round(dim(DATA)[1]*fractionWarmUp,0))
  }
  message(paste("Using",warmup,"time steps to warmup."))

  # performance period, period for which indices were calculated
  pperiod <- (warmup + 1):dim(DATA)[1]
  observedQ <- coredata(DATA[pperiod,"Q"])

  # load list of availabe models
  ModelList <- PrepareTable()
  if (!is.null(selectedModels)) {
    ModelList <- ModelList[which(ModelList$mid %in% selectedModels),]
  }

  # Find out how many parameter sets were used by looking at the first output
  discharges <- NULL
  load(paste(ResultsFolder, dir(ResultsFolder)[1], sep=""))
  numberOfParamSets <- dim(discharges)[1]

  # Make a table with all the combinations of models and params
  ALLrealisations <- data.frame("mid" = rep(seq(1,1248,2),
                                            each = numberOfParamSets),
                                "pid" = rep(1:numberOfParamSets,
                                            times = length(ModelList$mid)))

  IE <- BuildEnsemble(observedQ = observedQ,
                      SimulationFolder = ResultsFolder,
                      realisations = ALLrealisations,
                      lowerP = 0.05, upperP = 0.95, # These are ignored
                      verbose = verbose,
                      outputQ = FALSE, bigfile = FALSE, # These are ignored
                      minmaxOnly = TRUE)
  # saveRDS(IE, "IEReal.rds")
  # IE <- readRDS("IEReal.rds")

  accuracyIEminmax <- accuracy(Qobs = observedQ,
                               lowerBound = IE$minQ,
                               upperBound = IE$maxQ)

  message(paste("Accuracy IE max and min bounds =", accuracyIEminmax))

  # Build Initial Ensemble of MPIs #############################################
  IndicesRaw <- Simulations2Indices(ModelList, ResultsFolder, numberOfParamSets,
                                    nIndices=length(ObsIndicesNames), verbose)
  # saveRDS(IndicesRaw, "IndicesRawReal.rds")
  # IndicesRaw <- readRDS("IndicesRawReal.rds")

  ### BUILD ARRAY P ############################################################
  # The ObsIndices should all be 0. There is no need to substract the true
  # (observed) indices from the raw one + absolute value.
  # Just calculate the absolute value, then rescale between 0 and 1.
  Indices <- RescaleIndices(IndicesRaw)
  rm(IndicesRaw)
  # saveRDS(Indices, "IndicesReal.rds")
  # Indices <- readRDS("IndicesReal.rds")

  ### PRELIMINARY SELECTION ####################################################
  if (PreSel == TRUE){

    myThreshold <- SetThreshold(ModelList, Indices, verbose)
    temp <- PreSelection(ModelList, Indices, threshold = myThreshold)
    PS <- ExtendTable(realisations = temp, ModelList = ModelList,
                      Indices = Indices, parameters = parameters,
                      ObsIndicesNames = ObsIndicesNames, verbose)

  }else{

    PS <- ExtendTable(realisations = ALLrealisations,
                      ModelList = ModelList,
                      Indices = Indices, parameters = parameters,
                      ObsIndicesNames = ObsIndicesNames, verbose)

  }

  # saveRDS(PS, "PSReal.rds")

  # PS <- readRDS("PSReal.rds")
  # T1 <- BuildEnsemble(observedQ = observedQ,
  #                     SimulationFolder = ResultsFolder,
  #                     realisations = PS,
  #                     lowerP = 0.05, upperP = 0.95,
  #                     verbose = verbose, outputQ = TRUE,
  #                     bigfile = FALSE, minmaxOnly = FALSE)
  # saveRDS(T1, "T1Real.rds")
  # T1 <- readRDS("T1Real.rds")
  # accuracy(Qobs=observedQ, lowerBound=T1$bounds$lQ, upperBound=T1$bounds$uQ)
  # precision(lowerBound1 = IE$minQ, upperBound1 = IE$maxQ,
  #           lowerBound2 = T1$bounds$lQ, upperBound2 = T1$bounds$uQ)

  ### PARETO FRONTIER ##########################################################
  # library(emoa)
  # The pareto frontier is only applied to the indices
  PF <- ParetoFrontier(PS, ObsIndicesNames)
  # saveRDS(PF, "PFReal.rds")

  # PF <- readRDS("PFReal.rds")
  # T2 <- BuildEnsemble(observedQ = observedQ,
  #                     SimulationFolder = ResultsFolder,
  #                     realisations = PF,
  #                     lowerP = 0.05, upperP = 0.95,
  #                     verbose = verbose, outputQ = TRUE,
  #                     bigfile = FALSE, minmaxOnly = FALSE)
  # saveRDS(T2, "T2Real.rds")
  # T2 <- readRDS("T2Real.rds")
  # accuracy(Qobs=observedQ, lowerBound=T2$bounds$lQ, upperBound=T2$bounds$uQ)
  # precision(lowerBound1 = IE$minQ, upperBound1 = IE$maxQ,
  #           lowerBound2 = T2$bounds$lQ, upperBound2 = T2$bounds$uQ)

  ### REDUNDANCY REDUCTION #####################################################
  # library(som)
  # library(dtw)
  RE <- RedundancyReduction(PF, observedQ, ResultsFolder,
                            ObsIndicesNames, verbose)
  # saveRDS(RE, "REReal.rds")

  # RE <- readRDS("REReal.rds")
  T3 <- BuildEnsemble(observedQ = observedQ,
                      SimulationFolder = ResultsFolder,
                      realisations = RE,
                      lowerP = 0.05, upperP = 0.95,
                      verbose = verbose, outputQ = TRUE,
                      bigfile = FALSE, minmaxOnly = FALSE)
  # saveRDS(T3, "T3Real.rds")
  # T3 <- readRDS("T3Real.rds")
  accuracyRE <- accuracy(Qobs=observedQ,
                         lowerBound=T3$bounds$lQ, upperBound=T3$bounds$uQ)
  precisionRE <- precision(lowerBound1 = IE$minQ,
                           upperBound1 = IE$maxQ,
                           lowerBound2 = T3$bounds$lQ,
                           upperBound2 = T3$bounds$uQ)

  # REVIEW #####################################################################
  # RE's STATISTICAL RELIABILITY
  reliabilityRE <- reliability(T3$discharges, IE$Qobs)

  # RE's probabilistic NS
  pNSRE <- pNS(observedQ, T3$discharges)

  return(list("IE" = IE, "PS" = PS, "PF" = PF, "RE" = RE,
              "accuracyRE" = accuracyRE, "precisionRE" = precisionRE,
              "reliabilityRE" = reliabilityRE, "pNSRE" = pNSRE))

}
