#' Run the AMCA algorithm.
#'
#' @param DATA This is a data.frame containing the observed time series (zoo objects). It is structured into three columns: P containing precipitation, E containing potential evapotranspiration and Q containing streamflow discharge.
#' @param parameters is a data.frame containing all the parameter sets. This can be generated by \code{fuse::generateParameters()}.
#' @param deltim time step for FUSE simulations
#' @param warmup Percentage of initial time steps to ignore (default is 0.5 that corresponds to 50 percent of the full length).
#' @param ObsIndicesNames Names of model performance indices.
#' @param selectedModels (OPTIONAL) This is a table that contains at list 1 column named \code{mid} (list of model structures). Other informations can be added as additional columns but will be ignored (default = NULL).
#' @param ResultsFolder Path to the folder containing results from MC simulations. By default this is the working directory.
#' @param verbose if set to TRUE it prints running information (default is FALSE).
#'
#' @return A list of suggested model configurations.
#' 
#' @export
#'
#' @examples
#' # results <- amca(DATA, ResultsFolder)
#'

amca <- function(DATA,
                 parameters,
                 deltim = 1,
                 warmup = 0,
                 ObsIndicesNames = c("LAGTIME","MAE","NSHF","NSLF", "RR"),
                 selectedModels = NULL,
                 ResultsFolder = getwd(),
                 verbose = FALSE){

  ##############################################################################
  # Preparing forcing inputs ###################################################
  ##############################################################################

  options(warn=-1) # do not print warnings

  if ( is.null(ResultsFolder) ) {
    message("Please specify ResultsFolder.")
    stop
  }

  if ( is.null(warmup) ) {
    # period to warmup the model
    fractionWarmUp <- 0.50 # 50%
    warmup <- ifelse(fractionWarmUp==0,0,round(dim(DATA)[1]*fractionWarmUp,0))
  }
  message(paste("Using",warmup,"time steps to warmup."))

  # performance period, period for which indices were calculated
  pperiod <- (warmup + 1):dim(DATA)[1]
  observedQ <- zoo::coredata(DATA[pperiod,"Q"])

  # load list of availabe models
  ModelList <- PrepareTable()
  if (!is.null(selectedModels)) {

    ModelList <- ModelList[which(ModelList$mid %in% selectedModels),]

  } else {

    # Initial screening tests ##################################################

    # Is the rainfall error ignored?
    if ( all(parameters$rferr_add == 0) & all(parameters$rferr_mlt == 1) ) {
      ModelList <- ModelList[ModelList$rferr == 11,]
    }

    # Should the routing be ignored?
    if ( all(parameters$timedelay == 0) ) {
      ModelList <- ModelList[ModelList$q_tdh == 81,]
    }
  }

  # Find out how many parameter sets were used
  numberOfParamSets <- dim(parameters)[1]

  # Make a table with models and params identification numbers
  ALLrealisations <- data.frame("mid" = rep(ModelList$mid,
                                            each = numberOfParamSets),
                                "pid" = rep(1:numberOfParamSets,
                                            times = length(ModelList$mid)))

  IE <- BuildEnsemble(observedQ = observedQ,
                      SimulationFolder = ResultsFolder,
                      realisations = ALLrealisations,
                      verbose = verbose,
                      minmaxOnly = TRUE)

  accuracyIEminmax <- accuracy(Qobs = observedQ,
                               lowerBound = IE$minQ,
                               upperBound = IE$maxQ)

  message(paste("Accuracy IE max and min bounds = ",
                accuracyIEminmax, "%", sep = ""))
  message("Precision IE max and min bounds = 0% (by definition)")

  # Build Initial Ensemble of MPIs #############################################
  IndicesRaw <- Simulations2Indices(ModelList = ModelList,
                                    ResultsFolder = ResultsFolder,
                                    nParams = numberOfParamSets,
                                    nIndices = length(ObsIndicesNames),
                                    verbose = verbose)

  # The ObsIndices should all be 0. There is no need to substract the true
  # (observed) indices from the raw one + absolute value.
  # Just calculate the absolute value, then rescale between 0 and 1.
  Indices <- RescaleIndices(IndicesRaw)

  IEtable <- ExtendTable(realisations = ALLrealisations,
                         ModelList = ModelList,
                         Indices = Indices,
                         parameters = parameters,
                         ObsIndicesNames = ObsIndicesNames,
                         verbose = verbose,
                         onlyIndices = TRUE)

  ### PARETO FRONTIER ##########################################################
  # library(emoa)
  # The pareto frontier is only applied to the indices
  PF <- ParetoFrontier(realisations = IEtable,
                       ObsIndicesNames = ObsIndicesNames)

  ### REDUNDANCY REDUCTION #####################################################
  # library(som)
  # library(dtw)
  RE <- RedundancyReduction(DATA = DATA,
                            PF = PF,
                            observedQ = observedQ,
                            parameters = parameters,
                            deltim = deltim,
                            warmup = warmup,
                            ResultsFolder = ResultsFolder,
                            ObsIndicesNames = ObsIndicesNames,
                            verbose = verbose)

  T3 <- BuildEnsemble(observedQ = observedQ,
                      SimulationFolder = ResultsFolder,
                      realisations = RE,
                      lowerP = 0.05, upperP = 0.95,
                      verbose = verbose, outputQ = TRUE,
                      bigfile = FALSE, minmaxOnly = FALSE)

  # REVIEW #####################################################################
  # RE's ACCURACY
  accuracyRE <- accuracy(Qobs=observedQ,
                         lowerBound=T3$bounds$lQ, upperBound=T3$bounds$uQ)

  # RE's PRECISION
  precisionRE <- precision(lowerBound1 = IE$minQ,
                           upperBound1 = IE$maxQ,
                           lowerBound2 = T3$bounds$lQ,
                           upperBound2 = T3$bounds$uQ)

  # RE's STATISTICAL RELIABILITY
  reliabilityRE <- reliability(T3$discharges, IE$Qobs)

  message(paste("Accuracy RR (90% P.I.) = ", accuracyRE, "%", sep = ""))
  message(paste("Precision RR (90% P.I.) = ", precisionRE, "%", sep = ""))
  message(paste("Reliability RR (90% P.I.) = ", reliabilityRE, "%", sep = ""))

  return(list("PF" = PF, "RE" = RE, "ts" = T3))

}
